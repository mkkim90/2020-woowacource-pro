## 쿼리  순서가 어떻게 되나요?
  -> FROM
  -> WHERE 
  -> GROUP BY 
  -> HAVING
  -> SELECT에서는 그룹화하고 필터링한 데이터 집합을 집계
  -> ORDER BY를 통해 집계한 데이터 집합을 정렬합니다.

## 서브쿼리
  SELECT 절에 추가
  FRIM 절에 추가
  WHERE 절에 추가

## SQL 튜닝이라는 것을 뭐라고 생각하세요?
  SQL을 최적화하여 필요이상의 데이터 블록을 읽는 것을 방지합니다
  즉, SQL 튜닝이란 읽는 블록 수를 줄여주는 것을 의미합니다.

## 쿼리동작방식을 말씀해주실 수 있나요? 

  `쿼리캐싱`을 결과를 반환합니다. 
	- 요청된 쿼리 문자이 쿼리 캐시에 존재하는가
	- 해당 사용자가 그 결과를 볼 수 있는 권한이 있는가
	- 트랜잭션 내에서 실행된 쿼리의 경우 가시 범위 내에 있는 결과인가?
	- 호출 시점에 따라 결과가 달라지는 요소(RAND, CURRENT_DATE 등) 가 있는가?
	- 캐시가 만들어지고 난 이후 해당 데이터가 다른 사용자에 의해 변경되지 않았는가?
	- 쿼리에 의해 만들어진 결과가 캐시하기에 너무 크지 않은가

  `파싱`은 sql을 서버가 이해할 수 있는 수준으로 분리합니다

  `프리프로쎄서`는 해당 쿼리가 문법으로 틀리지 않은지 확인하여 부정확하다면 처리를 중단합니다.

  `옵티미제이션`은 실행계획을 통한 최적화 하는 역할을 합니다.
	 쿼리분석 
	 인덱스를 선택
	 조인처리 하는 과정등을 합니다. 

  `핸들러(스토리지 엔진)`
  Mysql 실행엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로 부터 읽어오는 역할을 담당합니다.


## Index Range Scan과 table full Scan

  - 테이블 전체를 스캔한다
  - 인덱스를 활용한다.

## 인덱스를 타는게 꼭 성능상 유리할까요?
  보통 효율적으로 사용을 하지만 읽을 데이터가 일정량을 넘으면 인덱스보다 Table Full Scan이 유리합니다.
  왜냐하면 테이블 풀스캔은 multiblock I/O방식으로 디스크를 읽어 한 블록에 속한 모든 레코드를 한번에 읽어들이는 반해, 
  Index Range Scan은 랜덤 엑세스와 Single Block I/O로 레코드 하나를 읽기 위해 매번 I/O가 발생하기 때문입니다.


## 인덱스 튜닝에 대해서 설명해보세요
	인덱스 스캔 효율화 , 랜덤 엑세스 최소화하는 관점으로 진행해야합니다.

  필요에 따라서 
  조건절이 복합이라면 결합인덱스를 활용해서 랜덤엑세스 횟수를 줄일 수 있는 방법도 있을 것 같습니다.

## 인덱스 할때 주의 사항이 있을까요? 

	결합인덱스를 할 시, where 절 조합순서,  
	Like를 쓰고 %를 앞에 쓴다든지, 
	칼럼이 변형하는 메서스를 활용한다든지, 
	전혀 다른 데이터타입으로 비교한다든지, 
	
물론 DB 종류 마다 다르겠지만 이런 부분을 실행계획을 통해 점검해보는 것이 좋다고 생각합니다.

## 페이징쿼리 성능을 올리는 방법으로 뭐가 있을까요 ?

  	Select * from interview where id limit 2000, 10;

### 이 페이징 쿼리가 왜 느릴까요? 
  OFFSET, LIMIT을 통해 최신 순에서 과거순으로 앞에서 읽었던 행을 다시 읽어야하기 때문입니다. 
  
  pk를 활용해서 where조건에 넣어주는 방법도 있습니다. 
  
  	Select * from interview where id >= 2000
  	Order by id limit 0, 10

  방식으로 활용하는 것입니다. 

## 커버링 인덱스란 뭐죠?  
  인덱스 스캔과정에서 select에 인덱스 컬럼을 사용하면 인덱스 스캔과정에서 얻은 정보만으로 처리할 수 있어
  테이블 엑세스가 발생하지 않는 쿼리를 의미합니다. 


## 테이블의 조회범위를 줄이는 방법에는 어떤게 있을까요? 
  조인이나 중첩쿼리를 조건절을 활용하여 조회범위를 줄여나갑니다. 테이블이 큰거 순에서 작은거로 조인을 거는 방식으로 처리합니다.


## 파티션 활용방안에 대해서 설명해주세요.
  일정량을 넘어 인덱스보다 Table Full Scan이 유리할 경우, 파티션 활용을 하는 것도 하나의 대안입니다. 
  로그성의 데이터들을 일자별 혹은 연도별로 구성하는 방식으로 파티셔닝을 통해 성능을 향상시킬 수 있습니다. 
