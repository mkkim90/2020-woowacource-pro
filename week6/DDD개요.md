
# 도메인 주도 설계
	- 도메인 모델의 적용 범위를 구현까지 확장하여 도메인 지식을 구현 코드에 반영

  - 도메인 : 일반적인 요구사항, 전문용어, 문제영역
  
  - 도메인 모델 : 도메인을 개념적으로 표현


## BOUNDED CONTEXT 
	
  - 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 한 개의 모델로 모든 하위 도메인을 표현하기는 쉽지 않으며 올바른 방법이 아니다. 
  - 하위도메인마다 사용하는 용어가 다르기 때문에 올바른 도메인모델을 개발하려면 하위 도메인마다 모델을 만들어야한다. 
  - 모델은 특정한 컨텍스트(문맥)하에서 완전한 의미를 갖는다.
  - 이렇게 구분되는 경계를 갖는 컨텍스트를 DDD에서는 "BOUNDED CONTEXT"라고 부른다. 

  -하나의 BOUNDED  CONTEXT는 하나의 팀에만 할당되어야 한다.
	  - 하나의 팀은 여러 개의 BOUNDED CONTEXT를 다룰 수 있다. 


## 엔티티와 벨류
  - 도출한 모델은 크게 엔티티와 벨류로 구분
  - 데이터와 함께 도메인 기능을 제공한다.

### VALUE OBJECT
  -벨류 타입은 불변
  -의미를 명확하게 표현하거나 두개 이상의 데이터가 개념적으로 하나인 경우 벨류 타입을 이용
  -항상 equlas() 메서드를 오버라이드할 것을 권고한다. 
	  equals를 재정의하려거든 hashCode도 재정의하라 - Effective Java
  -벨류 객체의 값을 변경하는 방법은 새로운 벨류 객체를 할당하는 것뿐이다. 

```
class Money {
	private final int dollars;

	public Cash mul(int factor) {
		return new Money(this.dollars * factor);
	}
}
```

```
Money six = new Money(6);
Money sixty = six.mul(10);
```

## Entity
  -식별자를 갖는다 
	  - 특정규칙에 따라 생성
	  - UUID 사용
	  - 값을 직접 입력
	  - 일련번호 사용

  -> 값이 변해도 식별할 필요, 동일성 보장

## Aggregate ( 유사어 비즈니스룰) 
  
  - 관련 객체를 하나로 묶은 군집
  - 애그리거트는 군집에 속한 객체들을 관리하는 루트 앤티티를 갖음
  - 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다 (-> 일관성 유지)
  - 한 애그리거트에 속한 객체는 다른 애그리커트에 속하지 않는다 (중복 불가)

  *루트 앤티티 - 애그리거트 루트
	  - 일관성이 깨지지 않도록한다.
	  - 도메인기능을 구현
	  - 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화
	  - 루트 앤티티는 애그리거트에 속해 있는 엔티티와 벨류 객체를 이용해서 구현해야할 기능을 제공


## 리포지터리
  - 앤티티나 벨류가 요구사항에서도 도출되는 도메인 모델이라면 리포지터리는 구현을 위한 도메인 모델
  - 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의
  - 애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공
  - 리포지토리는 애그리거트(루트) 단위로 존재하며 테이블 단위로 존재하는 것이 아니다. 

## 도메인 서비스
  - 한 애그리거트에 넣기 애매한 도메인 개념을 구현하려면 애그리거트에 억지로 넣기보다는 도메인 서비스를 이용해서
    도메인 개념을 명시적으로 드러내면됨
  - 도메인 로직을 다룸 / 상태없이 로직만 다룸

## 도메인 주도 설계 아키텍처 개요

  PRESENTATION LAYER (표현영역)
 
  APPLICATION LAYER (응용영역)

  DOMAIN LAYER (도메인영역)

  INFRASTRUCTURE LAYER (인프라스트럭처 영역)


고 수준 모듈 (어떤의미 있는 단일 기능을 제공하는 모듈) -> 저 수준 모듈 (고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현)

고수준모듈의 의존문제
  - 고수준모듈이 저수준 모듈을 의존
  - 저수준 모듈의 변경에 따라 고수준 모듈의 영향을 받는다
  - 고수준 모듈만 테스트하기 어렵다
  - 다른 구현 기술을 사용하려면 코드의 많은 부분을 고쳐야한다. 

### DIP
  -  저 수준 모듈이 고 수준 모듈에 의존한다고 해서 이를 DIP 의존 역전 원칙이라고 부른다.
  -  고수준에서 저수준으로 의존할때 구현 교체가 어렵다는 문제와 테스트가 어려운 문제 해소할 수 있다.
  -  고수준 모듈은 더 이상 저 수준 모듈에 의존하지 않고 구현을 추상화한 인터페이스에 의존
